% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/loo.R
\name{loo.stanmstte}
\alias{loo.stanmstte}
\alias{loo}
\alias{waic}
\title{Information criteria and cross-validation}
\usage{
\method{loo}{stanmstte}(x, ..., cores = getOption("mc.cores", 1),
  save_psis = FALSE, k_threshold = NULL)
}
\arguments{
\item{x}{For \code{loo}, \code{waic}, and \code{kfold} methods, a fitted
  model object returned by one of the rstanarm modeling functions. See
  \link{stanreg-objects}.

  For \code{loo_model_weights}, \code{x} should be a "stanreg_list"
  object, which is a list of fitted model objects created by
  \code{\link{stanreg_list}}.}

\item{...}{For \code{compare_models}, \code{...} should contain two or more
  objects returned by the \code{loo}, \code{kfold}, or \code{waic} method
  (see the \strong{Examples} section, below).

  For \code{loo_model_weights}, \code{...} should contain arguments
  (e.g. \code{method}) to pass to the default
  \code{\link[loo]{loo_model_weights}} method from the \pkg{loo} package.}

\item{cores, save_psis}{Passed to \code{\link[loo]{loo}}.}

\item{k_threshold}{Threshold for flagging estimates of the Pareto shape
parameters \eqn{k} estimated by \code{loo}. See the \emph{How to proceed
when \code{loo} gives warnings} section, below, for details.}
}
\value{
The structure of the objects returned by \code{loo} and \code{waic}
  methods are documented in detail in the \strong{Value} section in
  \code{\link[loo]{loo}} and \code{\link[loo]{waic}} (from the \pkg{loo}
  package).
}
\description{
For models fit using MCMC, compute approximate leave-one-out
  cross-validation (LOO, LOOIC) or, less preferably, the Widely Applicable
  Information Criterion (WAIC) using the \pkg{\link[=loo-package]{loo}}
  package. Functions for \eqn{K}-fold cross-validation, model comparison,
  and model weighting/averaging are also provided. \strong{Note}:
  these functions are not guaranteed to work properly unless the \code{data}
  argument was specified when the model was fit. Also, as of \pkg{loo}
  version \code{2.0.0} the default number of cores is now only 1,  but we
  recommend using as many (or close to as many) cores as possible by setting
  the \code{cores} argument or using \code{options(mc.cores = VALUE)} to set
  it for an entire session.
}
\section{Approximate LOO CV}{
 The \code{loo} method for stanreg objects
  provides an interface to the \pkg{\link[=loo-package]{loo}} package for
  approximate leave-one-out cross-validation (LOO). The LOO Information
  Criterion (LOOIC) has the same purpose as the Akaike Information Criterion
  (AIC) that is used by frequentists. Both are intended to estimate the
  expected log predictive density (ELPD) for a new dataset. However, the AIC
  ignores priors and assumes that the posterior distribution is multivariate
  normal, whereas the functions from the \pkg{loo} package do not make this
  distributional assumption and integrate over uncertainty in the parameters.
  This only assumes that any one observation can be omitted without having a
  major effect on the posterior distribution, which can be judged using the
  diagnostic plot provided by the \code{\link[loo]{plot.loo}} method and the
  warnings provided by the \code{\link[loo]{print.loo}} method (see the
  \emph{How to Use the rstanarm Package} vignette for an example of this
  process).

  \subsection{How to proceed when \code{loo} gives warnings (k_threshold)}{
  The \code{k_threshold} argument to the \code{loo} method for \pkg{rstanarm}
  models is provided as a possible remedy when the diagnostics reveal
  problems stemming from the posterior's sensitivity to particular
  observations. Warnings about Pareto \eqn{k} estimates indicate observations
  for which the approximation to LOO is problematic (this is described in
  detail in Vehtari, Gelman, and Gabry (2017) and the
  \pkg{\link[=loo-package]{loo}} package documentation). The
  \code{k_threshold} argument can be used to set the \eqn{k} value above
  which an observation is flagged. If \code{k_threshold} is not \code{NULL}
  and there are \eqn{J} observations with \eqn{k} estimates above
  \code{k_threshold} then when \code{loo} is called it will refit the
  original model \eqn{J} times, each time leaving out one of the \eqn{J}
  problematic observations. The pointwise contributions of these observations
  to the total ELPD are then computed directly and substituted for the
  previous estimates from these \eqn{J} observations that are stored in the
  object created by \code{loo}.

  \strong{Note}: in the warning messages issued by \code{loo} about large
  Pareto \eqn{k} estimates we recommend setting \code{k_threshold} to at
  least \eqn{0.7}. There is a theoretical reason, explained in Vehtari,
  Gelman, and Gabry (2017), for setting the threshold to the stricter value
  of \eqn{0.5}, but in practice they find that errors in the LOO
  approximation start to increase non-negligibly when \eqn{k > 0.7}.
  }
}

\examples{
\donttest{
fit1 <- stan_glm(mpg ~ wt, data = mtcars)
fit2 <- stan_glm(mpg ~ wt + cyl, data = mtcars)

# compare on LOOIC
# (for bigger models use as many cores as possible)
loo1 <- loo(fit1, cores = 2)
print(loo1)
loo2 <- loo(fit2, cores = 2)
print(loo2)

# when comparing exactly two models, the reported 'elpd_diff'
# will be positive if the expected predictive accuracy for the
# second model is higher. the approximate standard error of the
# difference is also reported.
compare_models(loo1, loo2)
compare_models(loos = list(loo1, loo2)) # can also provide list

# when comparing three or more models they are ordered by
# expected predictive accuracy. elpd_diff and se_diff are relative
# to the model with best elpd_loo (first row)
fit3 <- stan_glm(mpg ~ disp * as.factor(cyl), data = mtcars)
loo3 <- loo(fit3, cores = 2, k_threshold = 0.7)
compare_models(loo1, loo2, loo3)

# setting detail=TRUE will also print model formulas
compare_models(loo1, loo2, loo3, detail=TRUE)

# Computing model weights
model_list <- stanreg_list(fit1, fit2, fit3)
loo_model_weights(model_list, cores = 2) # can specify k_threshold=0.7 if necessary

# if you have already computed loo then it's more efficient to pass a list
# of precomputed loo objects than a "stanreg_list", avoiding the need
# for loo_models weights to call loo() internally
loo_list <- list(fit1 = loo1, fit2 = loo2, fit3 = loo3) # names optional (affects printing)
loo_model_weights(loo_list)

# 10-fold cross-validation
(kfold1 <- kfold(fit1, K = 10))
kfold2 <- kfold(fit2, K = 10)
compare_models(kfold1, kfold2, detail=TRUE)

# Cross-validation stratifying by a grouping variable
# (note: might get some divergences warnings with this model but
# this is just intended as a quick example of how to code this)
library(loo)
fit4 <- stan_lmer(mpg ~ disp + (1|cyl), data = mtcars)
table(mtcars$cyl)
folds_cyl <- kfold_split_stratified(K = 3, x = mtcars$cyl)
table(cyl = mtcars$cyl, fold = folds_cyl)
kfold4 <- kfold(fit4, K = 3, folds = folds_cyl)
}

}
\seealso{
\itemize{
  \item The new \href{http://mc-stan.org/loo/articles/}{\pkg{loo} package vignettes}
  and various \href{http://mc-stan.org/rstanarm/articles/}{\pkg{rstanarm} vignettes}
  for more examples using \code{loo} and related functions with \pkg{rstanarm} models.
  \item \code{\link[loo]{pareto-k-diagnostic}} in the \pkg{loo} package for
  more on Pareto \eqn{k} diagnostics.
  \item \code{\link{log_lik.stanreg}} to directly access the pointwise
  log-likelihood matrix.
}
}
